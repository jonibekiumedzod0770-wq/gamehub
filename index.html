<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>GameHub</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1a1a2e;
            color: white;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            touch-action: none;
        }

        header {
            background-color: #16213e;
            padding: 10px;
            text-align: center;
            width: 100%;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        h1 { margin: 0; color: #0ff; font-size: 20px; }
        p { color: #aaa; margin: 5px 0 0; font-size: 12px; }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            padding: 10px;
            gap: 15px;
            overflow-y: auto;
            flex-grow: 1;
            align-content: flex-start;
        }

        .game-card {
            background: #16213e;
            width: 45%;
            min-width: 140px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.2s;
            cursor: pointer;
            border: 2px solid #333;
            padding-bottom: 10px;
        }
        .game-card:active { transform: scale(0.95); border-color: #e94560; }

        .card-img {
            width: 100%;
            height: 80px;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
        }
        .game-card h3 { margin: 8px 0; font-size: 16px; }

        #game-screen {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #111;
            z-index: 100;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }

        .score-board {
            font-size: 20px;
            margin-top: 10px;
            color: #0ff;
            height: 30px;
            text-shadow: 0 0 5px #0ff;
            text-align: center;
        }

        .game-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            overflow: hidden;
        }

        canvas {
            background-color: #000;
            display: block;
            border: 2px solid #333;
            max-width: 100%;
            max-height: 100%;
            touch-action: none;
        }

        .controls-container {
            width: 100%;
            background: #16213e;
            padding: 10px 0;
            padding-bottom: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .ctrl-btn {
            background: #0f3460;
            color: white;
            border: 2px solid #e94560;
            font-size: 24px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .ctrl-btn:active { background: #e94560; transform: scale(0.95); }

        .dpad-grid {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(2, 60px);
            gap: 5px;
        }
        .dpad-btn {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ms-controls {
            display: flex;
            width: 90%;
            gap: 10px;
        }
        .ms-btn {
            flex-grow: 1;
            height: 60px;
            font-size: 18px !important;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 30px;
            color: #fff;
            cursor: pointer;
            z-index: 101;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            text-align: center;
            line-height: 35px;
        }
    </style>
</head>
<body>

    <header>
        <h1>GameHub</h1>
        <p>–ò–≥—Ä—ã –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞</p>
    </header>

    <div class="container" id="menu">
        <div class="game-card" onclick="openGame('tetris')">
            <div class="card-img">üß±</div>
            <h3>–¢–µ—Ç—Ä–∏—Å</h3>
        </div>
        <div class="game-card" onclick="openGame('snake')">
            <div class="card-img">üêç</div>
            <h3>–ó–º–µ–π–∫–∞</h3>
        </div>
        <div class="game-card" onclick="openGame('racing')">
            <div class="card-img">üèéÔ∏è</div>
            <h3>–ì–æ–Ω–∫–∏</h3>
        </div>
        <div class="game-card" onclick="openGame('minesweeper')">
            <div class="card-img">üí£</div>
            <h3>–°–∞–ø—ë—Ä</h3>
        </div>
    </div>

    <div id="game-screen">
        <div class="close-btn" onclick="closeGame()">&times;</div>
        <div class="score-board" id="score-display">–°—á–µ—Ç: 0</div>
        
        <div class="game-area">
            <canvas id="game-canvas"></canvas>
        </div>

        <div class="controls-container" id="controls-panel"></div>
    </div>

    <script>
        /* --- –î–í–ò–ñ–û–ö --- */
        const menuScreen = document.getElementById('menu');
        const gameScreen = document.getElementById('game-screen');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const controlsPanel = document.getElementById('controls-panel');

        let currentGame = null;
        let animationId; 
        let gameInterval;
        
        function resizeCanvas(w, h) {
            const maxW = window.innerWidth - 10;
            const maxH = window.innerHeight - 200;
            let scale = Math.min(maxW / w, maxH / h, 1);
            canvas.style.width = (w * scale) + 'px';
            canvas.style.height = (h * scale) + 'px';
            canvas.width = w;
            canvas.height = h;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            return scale;
        }

        function openGame(gameName) {
            menuScreen.style.display = 'none';
            gameScreen.style.display = 'flex';
            currentGame = gameName;
            controlsPanel.innerHTML = '';

            if (gameName === 'tetris') startTetris();
            if (gameName === 'snake') startSnake();
            if (gameName === 'racing') startRacing();
            if (gameName === 'minesweeper') startMinesweeper();
        }

        function closeGame() {
            gameScreen.style.display = 'none';
            menuScreen.style.display = 'block';
            cancelAnimationFrame(animationId);
            clearInterval(gameInterval);
            currentGame = null;
            canvas.onmousedown = null;
            canvas.ontouchstart = null;
        }
        
        function createButtons(html) {
            controlsPanel.innerHTML = html;
            const btns = controlsPanel.querySelectorAll('.ctrl-btn');
            btns.forEach(btn => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if(btn.onclick) btn.onclick();
                }, {passive: false});
            });
        }

        document.addEventListener('keydown', (e) => {
            if (!currentGame) return;
            if (currentGame === 'tetris') tetrisKeyDown(e);
            if (currentGame === 'snake') snakeKeyDown(e);
            if (currentGame === 'racing') racingKeyDown(e);
        });

        /* --- –¢–ï–¢–†–ò–° --- */
        let t_arena, t_player, t_dropCounter, t_dropInterval, t_lastTime;
        
        function startTetris() {
            resizeCanvas(240, 400);
            ctx.scale(20, 20);
            t_arena = createMatrix(12, 20);
            t_player = { pos: {x:0, y:0}, matrix: null, score: 0 };
            t_dropCounter = 0; t_dropInterval = 1000; t_lastTime = 0;
            t_playerReset(); t_updateScore(); t_update();

            createButtons(`
                <div class="dpad-grid">
                    <div></div>
                    <button class="ctrl-btn dpad-btn" id="btn-up">‚ñ≤</button>
                    <div></div>
                    <button class="ctrl-btn dpad-btn" id="btn-left">‚óÄ</button>
                    <button class="ctrl-btn dpad-btn" id="btn-down">‚ñº</button>
                    <button class="ctrl-btn dpad-btn" id="btn-right">‚ñ∂</button>
                </div>
            `);
            document.getElementById('btn-up').onclick = () => t_playerRotate();
            document.getElementById('btn-down').onclick = () => t_playerDrop();
            document.getElementById('btn-left').onclick = () => t_playerMove(-1);
            document.getElementById('btn-right').onclick = () => t_playerMove(1);
        }
        
        function createMatrix(w, h) { return Array.from({length: h}, () => Array(w).fill(0)); }
        function t_createPiece(type) {
            if (type === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
            if (type === 'L') return [[0,2,0],[0,2,0],[0,2,2]];
            if (type === 'J') return [[0,3,0],[0,3,0],[3,3,0]];
            if (type === 'O') return [[4,4],[4,4]];
            if (type === 'Z') return [[5,5,0],[0,5,5],[0,0,0]];
            if (type === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
            if (type === 'T') return [[0,7,0],[7,7,7],[0,0,0]];
        }
        const t_colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
        function t_draw() { ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height); t_drawMatrix(t_arena, {x:0, y:0}); t_drawMatrix(t_player.matrix, t_player.pos); }
        function t_drawMatrix(matrix, offset) { matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { ctx.fillStyle = t_colors[value]; ctx.fillRect(x + offset.x, y + offset.y, 1, 1); } }); }); }
        function t_collide(arena, player) { const [m, o] = [player.matrix, player.pos]; for (let y = 0; y < m.length; ++y) { for (let x = 0; x < m[y].length; ++x) { if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true; } } return false; }
        function t_merge(arena, player) { player.matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value; }); }); }
        function t_arenaSweep() { let rowCount = 1; outer: for (let y = t_arena.length - 1; y > 0; --y) { for (let x = 0; x < t_arena[y].length; ++x) { if (t_arena[y][x] === 0) continue outer; } const row = t_arena.splice(y, 1)[0].fill(0); t_arena.unshift(row); ++y; t_player.score += rowCount * 10; rowCount *= 2; } t_updateScore(); }
        function t_playerDrop() { t_player.pos.y++; if (t_collide(t_arena, t_player)) { t_player.pos.y--; t_merge(t_arena, t_player); t_playerReset(); t_arenaSweep(); } t_dropCounter = 0; }
        function t_playerMove(dir) { t_player.pos.x += dir; if (t_collide(t_arena, t_player)) t_player.pos.x -= dir; }
        function t_playerRotate() { const matrix = t_player.matrix; for (let y = 0; y < matrix.length; ++y) { for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; } } matrix.forEach(row => row.reverse()); }
        function t_playerReset() { const pieces = 'ILJOTSZ'; t_player.matrix = t_createPiece(pieces[Math.random() * pieces.length | 0]); t_player.pos.y = 0; t_player.pos.x = (t_arena[0].length / 2 | 0) - (t_player.matrix[0].length / 2 | 0); if (t_collide(t_arena, t_player)) { t_arena.forEach(row => row.fill(0)); t_player.score = 0; t_updateScore(); } }
        function t_update(time = 0) { if (currentGame !== 'tetris') return; const deltaTime = time - t_lastTime; t_lastTime = time; t_dropCounter += deltaTime; if (t_dropCounter > t_dropInterval) t_playerDrop(); t_draw(); animationId = requestAnimationFrame(t_update); }
        function t_updateScore() { scoreEl.innerText = "–°—á–µ—Ç: " + t_player.score; }
        function tetrisKeyDown(e) { if (e.keyCode === 37) t_playerMove(-1); else if (e.keyCode === 39) t_playerMove(1); else if (e.keyCode === 40) t_playerDrop(); else if (e.keyCode === 38) t_playerRotate(); }

        /* --- –ó–ú–ï–ô–ö–ê --- */
        let s_score, s_snake, s_food, s_dx, s_dy, s_gridSize, s_tileCount;
        function startSnake() {
            resizeCanvas(400, 400);
            s_score = 0; s_gridSize = 20; s_tileCount = 20;
            s_snake = [{x: 10, y: 10}]; s_food = {x: 15, y: 15}; s_dx = 0; s_dy = 0;
            scoreEl.innerText = 0;
            clearInterval(gameInterval); gameInterval = setInterval(s_update, 100); s_draw();

            createButtons(`
                <div class="dpad-grid">
                    <div></div>
                    <button class="ctrl-btn dpad-btn" id="btn-up">‚ñ≤</button>
                    <div></div>
                    <button class="ctrl-btn dpad-btn" id="btn-left">‚óÄ</button>
                    <button class="ctrl-btn dpad-btn" id="btn-down">‚ñº</button>
                    <button class="ctrl-btn dpad-btn" id="btn-right">‚ñ∂</button>
                </div>
            `);
            document.getElementById('btn-up').onclick = () => s_setDirection(0, -1);
            document.getElementById('btn-down').onclick = () => s_setDirection(0, 1);
            document.getElementById('btn-left').onclick = () => s_setDirection(-1, 0);
            document.getElementById('btn-right').onclick = () => s_setDirection(1, 0);
        }
        function s_setDirection(x, y) { if (x === -s_dx && s_dx !== 0) return; if (y === -s_dy && s_dy !== 0) return; if (s_dx === 0 && s_dy === 0) { s_dx = x; s_dy = y; } else { s_dx = x; s_dy = y; } }
        function s_update() { if (currentGame !== 'snake') return; if (s_dx === 0 && s_dy === 0) { s_draw(); return; } const head = {x: s_snake[0].x + s_dx, y: s_snake[0].y + s_dy}; if (head.x < 0 || head.x >= s_tileCount || head.y < 0 || head.y >= s_tileCount) { s_gameOver(); return; } for (let part of s_snake) { if (part.x === head.x && part.y === head.y) { s_gameOver(); return; } } s_snake.unshift(head); if (head.x === s_food.x && head.y === s_food.y) { s_score++; scoreEl.innerText = s_score; s_placeFood(); } else { s_snake.pop(); } s_draw(); }
        function s_draw() { ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#0ff'; for (let part of s_snake) { ctx.fillRect(part.x * s_gridSize, part.y * s_gridSize, s_gridSize - 2, s_gridSize - 2); } ctx.fillStyle = '#e94560'; ctx.fillRect(s_food.x * s_gridSize, s_food.y * s_gridSize, s_gridSize - 2, s_gridSize - 2); if (s_dx === 0 && s_dy === 0) { ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.fillText('–ù–∞–∂–º–∏ —Å—Ç—Ä–µ–ª–∫—É!', canvas.width/2, canvas.height/2); } }
        function s_placeFood() { s_food.x = Math.floor(Math.random() * s_tileCount); s_food.y = Math.floor(Math.random() * s_tileCount); }
        function s_gameOver() { clearInterval(gameInterval); ctx.fillStyle = 'rgba(0,0,0,0.75)'; ctx.fillRect(0,0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.fillText('Game Over!', canvas.width/2, canvas.height/2 - 10); ctx.font = '20px Arial'; ctx.fillText('–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É', canvas.width/2, canvas.height/2 + 20); s_dx = 0; s_dy = 0; s_snake = [{x: 10, y: 10}]; s_score = 0; scoreEl.innerText = 0; gameInterval = setInterval(s_update, 100); }
        function snakeKeyDown(e) { switch (e.keyCode) { case 37: s_setDirection(-1, 0); break; case 38: s_setDirection(0, -1); break; case 39: s_setDirection(1, 0); break; case 40: s_setDirection(0, 1); break; } }

        /* --- –ì–û–ù–û–ö --- */
        let r_player, r_enemies, r_score, r_speed, r_roadLine, r_isGameOver;
        function startRacing() {
            resizeCanvas(400, 400);
            r_player = { x: 175, y: 350, width: 50, height: 80 }; r_enemies = []; r_score = 0; r_speed = 5; r_roadLine = 0; r_isGameOver = false; scoreEl.innerText = 0; r_spawnEnemy();
            
            createButtons(`
                <div class="dpad-grid">
                    <div></div><div></div><div></div>
                    <button class="ctrl-btn dpad-btn" id="btn-left">‚óÄ</button>
                    <div></div>
                    <button class="ctrl-btn dpad-btn" id="btn-right">‚ñ∂</button>
                </div>
            `);
            document.getElementById('btn-left').onclick = () => r_movePlayer(-20);
            document.getElementById('btn-right').onclick = () => r_movePlayer(20);
            r_update();
        }
        function r_movePlayer(dir) { r_player.x += dir; if (r_player.x < 50) r_player.x = 50; if (r_player.x + r_player.width > 350) r_player.x = 350 - r_player.width; }
        function r_spawnEnemy() { let x = Math.random() * (300 - 50) + 50; r_enemies.push({ x: x, y: -100, width: 50, height: 80 }); }
        function r_update() { if (currentGame !== 'racing') return; if (r_isGameOver) return; ctx.fillStyle = '#2c3e50'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(0, 0, 50, canvas.height); ctx.fillRect(350, 0, 50, canvas.height); r_roadLine += r_speed; if (r_roadLine > 40) r_roadLine = 0; ctx.fillStyle = '#f1c40f'; for (let i = -40; i < canvas.height; i += 40) { ctx.fillRect(195, i + r_roadLine, 10, 20); } if (Math.random() < 0.02) r_spawnEnemy(); r_enemies.forEach((enemy, index) => { enemy.y += r_speed; ctx.fillStyle = '#e74c3c'; ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height); if (r_collision(r_player, enemy)) r_gameOver(); if (enemy.y > canvas.height) { r_enemies.splice(index, 1); r_score++; scoreEl.innerText = r_score; if (r_score % 5 === 0) r_speed += 0.5; } }); ctx.fillStyle = '#3498db'; ctx.fillRect(r_player.x, r_player.y, r_player.width, r_player.height); ctx.fillStyle = '#f1c40f'; ctx.fillRect(r_player.x + 5, r_player.y, 10, 5); ctx.fillRect(r_player.x + 35, r_player.y, 10, 5); animationId = requestAnimationFrame(r_update); }
        function r_collision(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }
        function r_gameOver() { r_isGameOver = true; ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center'; ctx.fillText('–ê–í–ê–†–ò–Ø!', canvas.width/2, canvas.height/2); ctx.font = '20px Arial'; ctx.fillText('–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É', canvas.width/2, canvas.height/2 + 40); }
        function racingKeyDown(e) { if (r_isGameOver) { r_enemies = []; r_score = 0; r_speed = 5; r_isGameOver = false; scoreEl.innerText = 0; r_update(); return; } if (e.keyCode === 37) r_movePlayer(-20); if (e.keyCode === 39) r_movePlayer(20); }

        /* --- –°–ê–ü–Å–† (–ò–°–ü–†–ê–í–õ–ï–ù–û) --- */
        let m_grid, m_cols, m_rows, m_cellSize, m_minesCount, m_gameOver, m_flagMode;
        const m_numbers = ['blue', 'green', 'red', 'darkblue', 'brown', 'cyan', 'black', 'grey'];
        function startMinesweeper() {
            m_cols = 10; m_rows = 10; m_cellSize = 30;
            resizeCanvas(m_cols * m_cellSize, m_rows * m_cellSize);
            m_minesCount = 15; m_gameOver = false; m_flagMode = false;
            m_createGrid();
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞
            canvas.onmousedown = (e) => m_handleClick(e);
            canvas.ontouchstart = (e) => {
                e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å–∫—Ä–æ–ª–ª
                m_handleClick(e.touches[0]); // –ü–µ—Ä–µ–¥–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–∞—Å–∞–Ω–∏—è
            };

            createButtons(`
                <div class="ms-controls">
                    <button class="ctrl-btn ms-btn" id="btn-flag">üö© –§–ª–∞–∂–æ–∫</button>
                    <button class="ctrl-btn ms-btn" id="btn-restart">üîÑ –ó–∞–Ω–æ–≤–æ</button>
                </div>
            `);
            
            document.getElementById('btn-flag').onclick = () => {
                m_flagMode = !m_flagMode;
                document.getElementById('btn-flag').style.background = m_flagMode ? '#e94560' : '#0f3460';
                document.getElementById('btn-flag').innerText = m_flagMode ? "üö© –†–µ–∂–∏–º: –§–ª–∞–≥" : "üö© –§–ª–∞–∂–æ–∫";
            };
            document.getElementById('btn-restart').onclick = startMinesweeper;
        }
        function m_createGrid() { m_grid = []; for (let i = 0; i < m_cols; i++) { m_grid[i] = []; for (let j = 0; j < m_rows; j++) { m_grid[i][j] = { mine: false, revealed: false, flagged: false, neighborCount: 0 }; } } let minesPlaced = 0; while (minesPlaced < m_minesCount) { let x = Math.floor(Math.random() * m_cols); let y = Math.floor(Math.random() * m_rows); if (!m_grid[x][y].mine) { m_grid[x][y].mine = true; minesPlaced++; } } for (let i = 0; i < m_cols; i++) { for (let j = 0; j < m_rows; j++) { if (!m_grid[i][j].mine) { m_grid[i][j].neighborCount = m_countMines(i, j); } } } m_draw(); }
        function m_countMines(x, y) { let count = 0; for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { let ni = x + i, nj = y + j; if (ni >= 0 && ni < m_cols && nj >= 0 && nj < m_rows) { if (m_grid[ni][nj].mine) count++; } } } return count; }
        function m_draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); for (let i = 0; i < m_cols; i++) { for (let j = 0; j < m_rows; j++) { let cell = m_grid[i][j]; let x = i * m_cellSize; let y = j * m_cellSize; if (cell.revealed) { ctx.fillStyle = cell.mine ? '#e74c3c' : '#ecf0f1'; } else { ctx.fillStyle = cell.flagged ? '#f1c40f' : '#bdc3c7'; } ctx.fillRect(x + 1, y + 1, m_cellSize - 2, m_cellSize - 2); if (cell.revealed) { if (cell.mine) { ctx.fillStyle = 'black'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText('üí£', x + m_cellSize/2, y + m_cellSize/2 + 5); } else if (cell.neighborCount > 0) { ctx.fillStyle = m_numbers[cell.neighborCount - 1]; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText(cell.neighborCount, x + m_cellSize/2, y + m_cellSize/2 + 5); } } else if (cell.flagged) { ctx.fillStyle = 'red'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText('üö©', x + m_cellSize/2, y + m_cellSize/2 + 5); } } } }
        
        // –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ö–õ–ò–ö–ê
        function m_handleClick(e) { 
            if (m_gameOver) return;
            let rect = canvas.getBoundingClientRect();
            // –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–± –¥–ª—è –∫–∞—Å–∞–Ω–∏—è
            let scaleX = canvas.width / rect.width;
            let scaleY = canvas.height / rect.height;
            
            // –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å–µ—Ç–∫–∏
            let x = Math.floor((e.clientX - rect.left) * scaleX / m_cellSize);
            let y = Math.floor((e.clientY - rect.top) * scaleY / m_cellSize);
            
            // –ó–∞—â–∏—Ç–∞ –æ—Ç –≤—ã—Ö–æ–¥–∞ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –º–∞—Å—Å–∏–≤–∞
            if (x < 0 || x >= m_cols || y < 0 || y >= m_rows) return;

            if (m_flagMode) {
                m_toggleFlag(x, y);
            } else {
                m_reveal(x, y);
            }
        }
        
        function m_toggleFlag(x, y) { if (!m_grid[x][y].revealed) { m_grid[x][y].flagged = !m_grid[x][y].flagged; m_draw(); } }
        function m_reveal(x, y) { if (x < 0 || x >= m_cols || y < 0 || y >= m_rows) return; let cell = m_grid[x][y]; if (cell.revealed || cell.flagged) return; cell.revealed = true; if (cell.mine) { m_gameOver = true; scoreEl.innerText = "–ë–ê–ë–ê–•! üí•"; m_revealAll(); m_draw(); return; } if (cell.neighborCount === 0) { for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { m_reveal(x + i, y + j); } } } m_draw(); m_checkWin(); }
        function m_revealAll() { for (let i = 0; i < m_cols; i++) { for (let j = 0; j < m_rows; j++) { m_grid[i][j].revealed = true; } } }
        function m_checkWin() { let unrevealedSafe = 0; for (let i = 0; i < m_cols; i++) { for (let j = 0; j < m_rows; j++) { let c = m_grid[i][j]; if (!c.revealed && !c.mine) unrevealedSafe++; } } if (unrevealedSafe === 0) { scoreEl.innerText = "–ü–û–ë–ï–î–ê! üèÜ"; m_gameOver = true; } }

    </script>
</body>
</html>
