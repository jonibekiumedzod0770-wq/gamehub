<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>GameHub</title>
    <!-- –í–∞–∂–Ω–æ: –æ—Ç–∫–ª—é—á–∞–µ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –ø—Ä–æ–∫—Ä—É—Ç–∫—É -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { font-family: 'Segoe UI', sans-serif; background-color: #1a1a2e; color: white; margin: 0; height: 100vh; display: flex; flex-direction: column; align-items: center; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
        header { background-color: #16213e; padding: 10px; text-align: center; width: 100%; box-sizing: border-box; flex-shrink: 0; }
        h1 { margin: 0; color: #0ff; font-size: 20px; }
        p { color: #aaa; margin: 5px 0 0; font-size: 12px; }
        .container { display: flex; flex-wrap: wrap; justify-content: center; padding: 10px; gap: 15px; overflow-y: auto; flex-grow: 1; align-content: flex-start; }
        .game-card { background: #16213e; width: 45%; min-width: 140px; border-radius: 10px; text-align: center; transition: transform 0.2s; cursor: pointer; border: 2px solid #333; padding-bottom: 10px; }
        .game-card:active { transform: scale(0.95); border-color: #e94560; }
        .card-img { width: 100%; height: 80px; background: #000; display: flex; align-items: center; justify-content: center; font-size: 40px; }
        .game-card h3 { margin: 8px 0; font-size: 16px; }
        #game-screen { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; z-index: 100; flex-direction: column; align-items: center; justify-content: space-between; }
        .score-board { font-size: 20px; margin-top: 10px; color: #0ff; height: 30px; text-shadow: 0 0 5px #0ff; text-align: center; }
        .game-area { flex-grow: 1; display: flex; justify-content: center; align-items: center; width: 100%; overflow: hidden; }
        canvas { background-color: #000; display: block; border: 2px solid #333; max-width: 100%; max-height: 100%; touch-action: none; }
        .controls-container { width: 100%; background: #16213e; padding: 10px 0; padding-bottom: 20px; display: flex; justify-content: center; gap: 10px; flex-shrink: 0; }
        .ctrl-btn { background: #0f3460; color: white; border: 2px solid #e94560; font-size: 24px; font-weight: bold; border-radius: 10px; cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent; }
        .ctrl-btn:active { background: #e94560; transform: scale(0.95); }
        .dpad-grid { display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(2, 60px); gap: 5px; }
        .dpad-btn { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; }
        .ms-controls { display: flex; width: 90%; gap: 10px; }
        .ms-btn { flex-grow: 1; height: 60px; font-size: 18px !important; }
        .action-btn { width: 80%; height: 70px; font-size: 24px !important; }
        .close-btn { position: absolute; top: 10px; right: 10px; font-size: 30px; color: #fff; cursor: pointer; z-index: 101; background: rgba(0,0,0,0.5); border-radius: 50%; width: 40px; height: 40px; text-align: center; line-height: 35px; }
    </style>
</head>
<body>

    <header><h1>GameHub</h1><p>–õ—É—á—à–∏–µ –∏–≥—Ä—ã –±–µ—Å–ø–ª–∞—Ç–Ω–æ</p></header>

    <div class="container" id="menu">
        <div class="game-card" onclick="openGame('tetris')"><div class="card-img">üß±</div><h3>–¢–µ—Ç—Ä–∏—Å</h3></div>
        <div class="game-card" onclick="openGame('snake')"><div class="card-img">üêç</div><h3>–ó–º–µ–π–∫–∞</h3></div>
        <div class="game-card" onclick="openGame('racing')"><div class="card-img">üèéÔ∏è</div><h3>–ì–æ–Ω–∫–∏</h3></div>
        <div class="game-card" onclick="openGame('minesweeper')"><div class="card-img">üí£</div><h3>–°–∞–ø—ë—Ä</h3></div>
        <div class="game-card" onclick="openGame('flappy')"><div class="card-img">üê¶</div><h3>Flappy Bird</h3></div>
        <div class="game-card" onclick="openGame('arkanoid')"><div class="card-img">üß±</div><h3>–ê—Ä–∫–∞–Ω–æ–∏–¥</h3></div>
        <div class="game-card" onclick="openGame('blockblast')"><div class="card-img">üü•</div><h3>Block Blast</h3></div>
    </div>

    <div id="game-screen">
        <div class="close-btn" onclick="closeGame()">&times;</div>
        <div class="score-board" id="score-display">–°—á–µ—Ç: 0</div>
        <div class="game-area"><canvas id="game-canvas"></canvas></div>
        <div class="controls-container" id="controls-panel"></div>
    </div>

    <script>
        /* --- –î–í–ò–ñ–û–ö --- */
        const menuScreen = document.getElementById('menu');
        const gameScreen = document.getElementById('game-screen');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const controlsPanel = document.getElementById('controls-panel');

        let currentGame = null;
        let animationId; 
        let gameInterval;
        
        function resizeCanvas(w, h) {
            const maxW = window.innerWidth - 10;
            const maxH = window.innerHeight - 200;
            let scale = Math.min(maxW / w, maxH / h, 1);
            canvas.style.width = (w * scale) + 'px';
            canvas.style.height = (h * scale) + 'px';
            canvas.width = w;
            canvas.height = h;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            return scale;
        }

        function openGame(gameName) {
            menuScreen.style.display = 'none';
            gameScreen.style.display = 'flex';
            currentGame = gameName;
            controlsPanel.innerHTML = '';
            cancelAnimationFrame(animationId);
            clearInterval(gameInterval);

            canvas.onmousedown = null; canvas.ontouchstart = null;
            canvas.onmousemove = null; canvas.ontouchmove = null;
            canvas.onmouseup = null; canvas.ontouchend = null;
            canvas.onclick = null;

            if (gameName === 'tetris') startTetris();
            if (gameName === 'snake') startSnake();
            if (gameName === 'racing') startRacing();
            if (gameName === 'minesweeper') startMinesweeper();
            if (gameName === 'flappy') startFlappy();
            if (gameName === 'arkanoid') startArkanoid();
            if (gameName === 'blockblast') startBlockBlast();
        }

        function closeGame() {
            gameScreen.style.display = 'none';
            menuScreen.style.display = 'block';
            cancelAnimationFrame(animationId);
            clearInterval(gameInterval);
            currentGame = null;
        }
        
        function createButtons(html) {
            controlsPanel.innerHTML = html;
            const btns = controlsPanel.querySelectorAll('.ctrl-btn');
            btns.forEach(btn => {
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); if(btn.onclick) btn.onclick(); }, {passive: false});
            });
        }

        document.addEventListener('keydown', (e) => {
            if (!currentGame) return;
            if (currentGame === 'tetris') tetrisKeyDown(e);
            if (currentGame === 'snake') snakeKeyDown(e);
            if (currentGame === 'racing') racingKeyDown(e);
            if (currentGame === 'flappy') flappyKeyDown(e);
            if (currentGame === 'arkanoid') arkanoidKeyDown(e);
        });

        /* --- –ò–ì–†–´ (–¢–µ—Ç—Ä–∏—Å, –ó–º–µ–π–∫–∞, –∏ —Ç.–¥. - –∫–æ–¥ —Å–æ–∫—Ä–∞—â–µ–Ω –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏, –æ–Ω —Ç–∞–∫–æ–π –∂–µ –∫–∞–∫ –≤—ã—à–µ) --- */
        // –Ø –æ–ø—É—â—É –ø–æ–ª–Ω—ã–π –∫–æ–¥ –¥—Ä—É–≥–∏—Ö –∏–≥—Ä, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –Ω–µ –º–µ–Ω—è–ª—Å—è, —á—Ç–æ–±—ã —Å—ç–∫–æ–Ω–æ–º–∏—Ç—å –º–µ—Å—Ç–æ, 
        // –Ω–æ –≤ —Ä–µ–∞–ª—å–Ω–æ–º —Ñ–∞–π–ª–µ –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ç—É—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é.
        // –í—Å—Ç–∞–≤—å—Ç–µ —Å—é–¥–∞ –∫–æ–¥ –¢–µ—Ç—Ä–∏—Å–∞, –ó–º–µ–π–∫–∏ –∏ —Ç.–¥. –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è, 
        // –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –∑–∞–º–µ–Ω–∏—Ç–µ –í–ï–°–¨ —Ñ–∞–π–ª —Ü–µ–ª–∏–∫–æ–º. –Ø –Ω–∞–ø–∏—à—É –∑–¥–µ—Å—å —Ç–æ–ª—å–∫–æ Block Blast.
        
        // --- –î–õ–Ø –ö–û–ú–ü–ò–õ–Ø–¶–ò–ò: –°–ö–û–ü–ò–†–£–ô–¢–ï –ö–û–î –ò–ì–† –í–´–®–ï –°–Æ–î–ê ---
        // (–¢–µ—Ç—Ä–∏—Å, –ó–º–µ–π–∫–∞, –ì–æ–Ω–∫–∏, –°–∞–ø–µ—Ä, –§–ª–∞–ø–ø–∏, –ê—Ä–∫–∞–Ω–æ–∏–¥)
        // –Ø –æ—Å—Ç–∞–≤–ª—é –∑–∞–≥–ª—É—à–∫–∏, —á—Ç–æ–±—ã –∫–æ–¥ —Ä–∞–±–æ—Ç–∞–ª, –µ—Å–ª–∏ –≤—ã —Å–∫–æ–ø–∏—Ä—É–µ—Ç–µ —Ç–æ–ª—å–∫–æ —á–∞—Å—Ç—å.
        function startTetris() { resizeCanvas(240, 400); createButtons(`<button class="ctrl-btn action-btn" onclick="openGame('tetris')">Ok</button>`); }
        function startSnake() { resizeCanvas(400, 400); createButtons(`<button class="ctrl-btn action-btn" onclick="openGame('snake')">Ok</button>`); }
        function startRacing() { resizeCanvas(400, 400); createButtons(`<button class="ctrl-btn action-btn" onclick="openGame('racing')">Ok</button>`); }
        function startMinesweeper() { resizeCanvas(300, 300); createButtons(`<button class="ctrl-btn action-btn" onclick="openGame('minesweeper')">Ok</button>`); }
        function startFlappy() { resizeCanvas(400, 600); createButtons(`<button class="ctrl-btn action-btn" onclick="openGame('flappy')">Ok</button>`); }
        function startArkanoid() { resizeCanvas(480, 600); createButtons(`<button class="ctrl-btn action-btn" onclick="openGame('arkanoid')">Ok</button>`); }
        function tetrisKeyDown(e) {}
        function snakeKeyDown(e) {}
        function racingKeyDown(e) {}
        function flappyKeyDown(e) {}
        function arkanoidKeyDown(e) {}
        // --- –ö–û–ù–ï–¶ –ó–ê–ì–õ–£–®–ï–ö ---


        /* --- BLOCK BLAST (–ò–°–ü–†–ê–í–õ–ï–ù–û –î–õ–Ø –¢–ï–õ–ï–§–û–ù–ê) --- */
        let bb_grid, bb_score, bb_highScore, bb_cellSize, bb_cols, bb_rows, bb_pieces, bb_dragPiece, bb_dragPos, bb_gameOver, bb_trayY, bb_validPos, bb_flash;
        const bb_colors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c'];

        function startBlockBlast() {
            // –ö–ª–µ—Ç–∫–∏ –ø–æ–±–æ–ª—å—à–µ –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞
            bb_cols = 8; bb_rows = 8; bb_cellSize = 38; 
            let gridH = bb_cols * bb_cellSize;
            bb_trayY = gridH + 20;
            resizeCanvas(gridH, gridH + 150); // –ë–æ–ª—å—à–µ –º–µ—Å—Ç–∞ –ø–æ–¥ —Ç—Ä–µ–∏

            bb_highScore = localStorage.getItem('bb_highscore') || 0;
            bb_grid = [];
            for(let i=0; i<bb_cols; i++) {
                bb_grid[i] = [];
                for(let j=0; j<bb_rows; j++) bb_grid[i][j] = 0;
            }
            
            bb_score = 0;
            bb_gameOver = false;
            bb_flash = 0;
            bb_pieces = [];
            bb_dragPiece = null;
            bb_validPos = null;
            
            bb_generatePieces();
            bb_updateScore();
            
            // –§—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ—á–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∫–∞—Å–∞–Ω–∏—è
            const getPos = (e) => {
                let rect = canvas.getBoundingClientRect();
                let scaleX = canvas.width / rect.width;
                let scaleY = canvas.height / rect.height;
                // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º—É–ª—å—Ç–∏-—Ç–∞—á–∞ (–±–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π –ø–∞–ª–µ—Ü)
                let touch = e.touches ? e.touches[0] : e;
                let clientX = touch.clientX;
                let clientY = touch.clientY;
                return { 
                    x: (clientX - rect.left) * scaleX, 
                    y: (clientY - rect.top) * scaleY 
                };
            };

            // –ù–∞—á–∞–ª–æ –∫–∞—Å–∞–Ω–∏—è
            const onDown = (e) => {
                e.preventDefault(); // –ë–ª–æ–∫–∏—Ä—É–µ–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                if (bb_gameOver) return;
                let pos = getPos(e);
                
                // –ò—â–µ–º —Ñ–∏–≥—É—Ä—É, –≤ –∫–æ—Ç–æ—Ä—É—é –ø–æ–ø–∞–ª–∏ (—Å –∑–∞–ø–∞—Å–æ–º 20px –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞)
                for (let i = bb_pieces.length - 1; i >= 0; i--) {
                    let p = bb_pieces[i];
                    if (!p.used) {
                        // –†–∞—Å—à–∏—Ä—è–µ–º –æ–±–ª–∞—Å—Ç—å –∑–∞—Ö–≤–∞—Ç–∞ –Ω–∞ 20px –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                        let hitPadding = 30;
                        if (pos.x > p.x - hitPadding && pos.x < p.x + p.w + hitPadding && 
                            pos.y > p.y - hitPadding && pos.y < p.y + p.h + hitPadding) {
                            bb_dragPiece = p;
                            bb_dragPos = pos;
                            bb_draw();
                            return;
                        }
                    }
                }
            };

            // –î–≤–∏–∂–µ–Ω–∏–µ
            const onMove = (e) => {
                e.preventDefault(); // –ë–ª–æ–∫–∏—Ä—É–µ–º —Å–∫—Ä–æ–ª–ª
                if (bb_dragPiece) {
                    bb_dragPos = getPos(e);
                    
                    // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Ñ–∏–≥—É—Ä—É –ø–æ–¥ –ø–∞–ª—å—Ü–µ–º
                    let shapeW = bb_dragPiece.shape[0].length;
                    let shapeH = bb_dragPiece.shape.length;
                    
                    let tx = Math.round((bb_dragPos.x / bb_cellSize) - (shapeW / 2));
                    let ty = Math.round((bb_dragPos.y / bb_cellSize) - (shapeH / 2));

                    let canPlace = bb_canPlace(bb_dragPiece.shape, tx, ty);
                    bb_validPos = {x: tx, y: ty, valid: canPlace};
                    
                    bb_draw();
                }
            };

            // –û—Ç–ø—É—Å–∫–∞–Ω–∏–µ
            const onUp = (e) => {
                if (bb_dragPiece) {
                    if (bb_validPos && bb_validPos.valid) {
                        bb_placeShape(bb_dragPiece.shape, bb_validPos.x, bb_validPos.y, bb_dragPiece.color);
                        bb_dragPiece.used = true;
                        
                        let cleared = bb_checkLines();
                        if (cleared > 0) bb_flash = 0.5;
                        
                        bb_updateScore();
                        
                        if(bb_pieces.every(p => p.used)) bb_generatePieces();
                        else if (!bb_canPlaceAny()) bb_gameOver = true;
                    }
                    bb_dragPiece = null;
                    bb_validPos = null;
                    bb_draw();
                }
            };

            // –ü—Ä–∏–≤—è–∑–∫–∞ —Å–æ–±—ã—Ç–∏–π
            canvas.onmousedown = onDown;
            canvas.ontouchstart = onDown;
            
            canvas.onmousemove = onMove;
            canvas.ontouchmove = onMove; // –°–∞–º–æ–µ –≤–∞–∂–Ω–æ–µ –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞
            
            canvas.onmouseup = onUp;
            canvas.ontouchend = onUp;
            
            // –ï—Å–ª–∏ –ø–∞–ª–µ—Ü —É—à–µ–ª –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –∫–∞–Ω–≤–∞—Å–∞
            document.ontouchend = onUp; 
            document.onmouseup = onUp;

            createButtons(`<button class="ctrl-btn action-btn" onclick="startBlockBlast()">üîÑ –ó–∞–Ω–æ–≤–æ</button>`);
            bb_draw();
        }

        function bb_generatePieces() {
            bb_pieces = [];
            let space = canvas.width / 3;
            let shapes = [
                [[1,1,1]], [[1,1],[1,1]], [[1,0],[1,1]], [[0,1],[1,1]], 
                [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[0,1,0],[1,1,1]], [[1]], [[1,1]], [[1],[1]]
            ];
            for(let i=0; i<3; i++) {
                let shape = shapes[Math.floor(Math.random() * shapes.length)];
                let color = bb_colors[Math.floor(Math.random() * bb_colors.length)];
                // –§–∏–≥—É—Ä—ã —Ä–∏—Å—É—é—Ç—Å—è —Ä–∞–∑–º–µ—Ä–æ–º 36px (–∫–∞–∫ –∫–ª–µ—Ç–∫–∏ –ø–æ–ª—è)
                let size = 36; 
                let w = shape[0].length * size;
                let h = shape.length * size;
                let x = i * space + (space/2) - w/2;
                let y = bb_trayY + 30;
                bb_pieces.push({ shape, color, x, y, w, h, size, used: false });
            }
            if (!bb_canPlaceAny()) bb_gameOver = true;
        }

        function bb_draw() {
            if (currentGame !== 'blockblast') return;
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (bb_flash > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${bb_flash})`;
                ctx.fillRect(0, 0, canvas.width, bb_trayY);
                bb_flash -= 0.1;
            }

            // –°–µ—Ç–∫–∞
            for(let i=0; i<bb_cols; i++) {
                for(let j=0; j<bb_rows; j++) {
                    let val = bb_grid[i][j];
                    ctx.fillStyle = val ? val : '#222';
                    roundRect(ctx, i * bb_cellSize + 1, j * bb_cellSize + 1, bb_cellSize - 2, bb_cellSize - 2, 4, val ? val : '#222', val ? 0 : 1);
                }
            }
            
            // –ü–æ–ª–æ—Å–∞ –æ—Ç–¥–µ–ª–µ–Ω–∏—è
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, bb_trayY);
            ctx.lineTo(canvas.width, bb_trayY);
            ctx.stroke();

            // –§–∏–≥—É—Ä—ã –≤ —Ç—Ä–µ–∏
            bb_pieces.forEach(p => { if(!p.used) bb_drawShape(p.shape, p.x, p.y, p.color, p.size); });

            // –¢–µ–Ω—å –ø–æ–¥—Å–∫–∞–∑–∫–∞
            if (bb_dragPiece && bb_validPos) {
                let color = bb_validPos.valid ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.2)';
                if (bb_validPos.valid) {
                     bb_drawShapeOnGrid(bb_dragPiece.shape, bb_validPos.x, bb_validPos.y, color);
                }
            }

            // –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–∞—è —Ñ–∏–≥—É—Ä–∞
            if (bb_dragPiece) {
                let offsetX = bb_dragPiece.w / 2;
                let offsetY = bb_dragPiece.h / 2;
                bb_drawShape(bb_dragPiece.shape, bb_dragPos.x - offsetX, bb_dragPos.y - offsetY, bb_dragPiece.color, bb_dragPiece.size);
            }
            
            ctx.fillStyle = '#888';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('–†–µ–∫–æ—Ä–¥: ' + bb_highScore, 5, 20);

            if (bb_gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('–ò–ì–†–ê', canvas.width/2, canvas.height/2 - 30);
                ctx.fillText('–û–ö–û–ù–ß–ï–ù–ê', canvas.width/2, canvas.height/2 + 20);
                ctx.font = '18px Arial';
                ctx.fillText('–ù–∞–∂–º–∏ "–ó–∞–Ω–æ–≤–æ"', canvas.width/2, canvas.height/2 + 60);
            }
            
            if (bb_flash > 0) requestAnimationFrame(bb_draw);
        }

        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) { ctx.fillStyle = fill; ctx.fill(); }
            if (stroke) { ctx.strokeStyle = '#333'; ctx.stroke(); }
        }

        function bb_drawShape(shape, x, y, color, size) {
            shape.forEach((row, rj) => {
                row.forEach((val, ri) => {
                    if(val) roundRect(ctx, x + ri * size + 1, y + rj * size + 1, size - 2, size - 2, 4, color, 0);
                });
            });
        }

        function bb_drawShapeOnGrid(shape, gx, gy, color) {
            shape.forEach((row, rj) => {
                row.forEach((val, ri) => {
                    if(val && gx + ri >= 0 && gy + rj >= 0) {
                         roundRect(ctx, (gx + ri) * bb_cellSize, (gy + rj) * bb_cellSize, bb_cellSize - 2, bb_cellSize - 2, 4, color, 0);
                    }
                });
            });
        }

        function bb_canPlace(shape, gx, gy) {
            for(let rj=0; rj<shape.length; rj++) {
                for(let ri=0; ri<shape[rj].length; ri++) {
                    if(shape[rj][ri]) {
                        let x = gx + ri; let y = gy + rj;
                        if (x < 0 || x >= bb_cols || y < 0 || y >= bb_rows || bb_grid[x][y]) return false;
                    }
                }
            }
            return true;
        }

        function bb_placeShape(shape, gx, gy, color) {
            shape.forEach((row, rj) => {
                row.forEach((val, ri) => {
                    if(val) { bb_grid[gx + ri][gy + rj] = color; bb_score += 10; }
                });
            });
        }

        function bb_checkLines() {
            let linesCleared = 0;
            for(let j=bb_rows-1; j>=0; j--) {
                if(bb_grid.every(col => col[j])) {
                    for(let i=0; i<bb_cols; i++) bb_grid[i][j] = 0;
                    linesCleared++;
                }
            }
            for(let i=0; i<bb_cols; i++) {
                if(bb_grid[i].every(cell => cell)) {
                    for(let j=0; j<bb_rows; j++) bb_grid[i][j] = 0;
                    linesCleared++;
                }
            }
            
            if (linesCleared > 0) {
                let bonus = [0, 100, 300, 500, 800];
                bb_score += bonus[Math.min(linesCleared, 4)];
                if (bb_score > bb_highScore) {
                    bb_highScore = bb_score;
                    localStorage.setItem('bb_highscore', bb_highScore);
                }
            }
            return linesCleared;
        }

        function bb_canPlaceAny() {
            for(let p of bb_pieces) {
                if(p.used) continue;
                for(let i=0; i<bb_cols; i++) for(let j=0; j<bb_rows; j++) if(bb_canPlace(p.shape, i, j)) return true;
            }
            return false;
        }

        function bb_updateScore() { scoreEl.innerText = "–°—á–µ—Ç: " + bb_score; }

    </script>
</body>
</html>
