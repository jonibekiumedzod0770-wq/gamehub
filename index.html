<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>GameHub</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { font-family: 'Segoe UI', sans-serif; background-color: #1a1a2e; color: white; margin: 0; height: 100vh; display: flex; flex-direction: column; align-items: center; overflow: hidden; touch-action: none; user-select: none; }
        header { background-color: #16213e; padding: 10px; text-align: center; width: 100%; box-sizing: border-box; flex-shrink: 0; }
        h1 { margin: 0; color: #0ff; font-size: 20px; }
        p { color: #aaa; margin: 5px 0 0; font-size: 12px; }
        .container { display: flex; flex-wrap: wrap; justify-content: center; padding: 10px; gap: 15px; overflow-y: auto; flex-grow: 1; align-content: flex-start; }
        .game-card { background: #16213e; width: 45%; min-width: 140px; border-radius: 10px; text-align: center; transition: transform 0.2s; cursor: pointer; border: 2px solid #333; padding-bottom: 10px; }
        .game-card:active { transform: scale(0.95); border-color: #e94560; }
        .card-img { width: 100%; height: 80px; background: #000; display: flex; align-items: center; justify-content: center; font-size: 40px; }
        .game-card h3 { margin: 8px 0; font-size: 16px; }
        #game-screen { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111; z-index: 100; flex-direction: column; align-items: center; justify-content: space-between; }
        .score-board { font-size: 20px; margin-top: 10px; color: #0ff; height: 30px; text-shadow: 0 0 5px #0ff; text-align: center; }
        .game-area { flex-grow: 1; display: flex; justify-content: center; align-items: center; width: 100%; overflow: hidden; }
        canvas { background-color: #000; display: block; border: 2px solid #333; max-width: 100%; max-height: 100%; touch-action: none; }
        .controls-container { width: 100%; background: #16213e; padding: 10px 0; padding-bottom: 20px; display: flex; justify-content: center; gap: 10px; flex-shrink: 0; }
        .ctrl-btn { background: #0f3460; color: white; border: 2px solid #e94560; font-size: 24px; font-weight: bold; border-radius: 10px; cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent; }
        .ctrl-btn:active { background: #e94560; transform: scale(0.95); }
        .dpad-grid { display: grid; grid-template-columns: repeat(3, 60px); grid-template-rows: repeat(2, 60px); gap: 5px; }
        .dpad-btn { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; }
        .ms-controls { display: flex; width: 90%; gap: 10px; }
        .ms-btn { flex-grow: 1; height: 60px; font-size: 18px !important; }
        .action-btn { width: 80%; height: 70px; font-size: 24px !important; }
        .close-btn { position: absolute; top: 10px; right: 10px; font-size: 30px; color: #fff; cursor: pointer; z-index: 101; background: rgba(0,0,0,0.5); border-radius: 50%; width: 40px; height: 40px; text-align: center; line-height: 35px; }
    </style>
</head>
<body>

    <header><h1>GameHub</h1><p>–õ—É—á—à–∏–µ –∏–≥—Ä—ã –±–µ—Å–ø–ª–∞—Ç–Ω–æ</p></header>

    <div class="container" id="menu">
        <div class="game-card" onclick="openGame('tetris')"><div class="card-img">üß±</div><h3>–¢–µ—Ç—Ä–∏—Å</h3></div>
        <div class="game-card" onclick="openGame('snake')"><div class="card-img">üêç</div><h3>–ó–º–µ–π–∫–∞</h3></div>
        <div class="game-card" onclick="openGame('racing')"><div class="card-img">üèéÔ∏è</div><h3>–ì–æ–Ω–∫–∏</h3></div>
        <div class="game-card" onclick="openGame('minesweeper')"><div class="card-img">üí£</div><h3>–°–∞–ø—ë—Ä</h3></div>
        <div class="game-card" onclick="openGame('flappy')"><div class="card-img">üê¶</div><h3>Flappy Bird</h3></div>
        <div class="game-card" onclick="openGame('arkanoid')"><div class="card-img">üß±</div><h3>–ê—Ä–∫–∞–Ω–æ–∏–¥</h3></div>
        <div class="game-card" onclick="openGame('blockblast')"><div class="card-img">üü•</div><h3>Block Blast</h3></div>
    </div>

    <div id="game-screen">
        <div class="close-btn" onclick="closeGame()">&times;</div>
        <div class="score-board" id="score-display">–°—á–µ—Ç: 0</div>
        <div class="game-area"><canvas id="game-canvas"></canvas></div>
        <div class="controls-container" id="controls-panel"></div>
    </div>

    <script>
        /* --- –î–í–ò–ñ–û–ö --- */
        const menuScreen = document.getElementById('menu');
        const gameScreen = document.getElementById('game-screen');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score-display');
        const controlsPanel = document.getElementById('controls-panel');

        let currentGame = null;
        let animationId; 
        let gameInterval;
        
        function resizeCanvas(w, h) {
            const maxW = window.innerWidth - 10;
            const maxH = window.innerHeight - 200;
            let scale = Math.min(maxW / w, maxH / h, 1);
            canvas.style.width = (w * scale) + 'px';
            canvas.style.height = (h * scale) + 'px';
            canvas.width = w;
            canvas.height = h;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            return scale;
        }

        function openGame(gameName) {
            menuScreen.style.display = 'none';
            gameScreen.style.display = 'flex';
            currentGame = gameName;
            controlsPanel.innerHTML = '';
            cancelAnimationFrame(animationId);
            clearInterval(gameInterval);

            canvas.onmousedown = null; canvas.ontouchstart = null;
            canvas.onmousemove = null; canvas.ontouchmove = null;
            canvas.onmouseup = null; canvas.ontouchend = null;
            canvas.onclick = null;

            if (gameName === 'tetris') startTetris();
            if (gameName === 'snake') startSnake();
            if (gameName === 'racing') startRacing();
            if (gameName === 'minesweeper') startMinesweeper();
            if (gameName === 'flappy') startFlappy();
            if (gameName === 'arkanoid') startArkanoid();
            if (gameName === 'blockblast') startBlockBlast();
        }

        function closeGame() {
            gameScreen.style.display = 'none';
            menuScreen.style.display = 'block';
            cancelAnimationFrame(animationId);
            clearInterval(gameInterval);
            currentGame = null;
        }
        
        function createButtons(html) {
            controlsPanel.innerHTML = html;
            const btns = controlsPanel.querySelectorAll('.ctrl-btn');
            btns.forEach(btn => {
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); if(btn.onclick) btn.onclick(); }, {passive: false});
            });
        }

        document.addEventListener('keydown', (e) => {
            if (!currentGame) return;
            if (currentGame === 'tetris') tetrisKeyDown(e);
            if (currentGame === 'snake') snakeKeyDown(e);
            if (currentGame === 'racing') racingKeyDown(e);
            if (currentGame === 'flappy') flappyKeyDown(e);
            if (currentGame === 'arkanoid') arkanoidKeyDown(e);
        });

        /* --- –¢–ï–¢–†–ò–° --- */
        let t_arena, t_player, t_dropCounter, t_dropInterval, t_lastTime;
        function startTetris() {
            resizeCanvas(240, 400); ctx.scale(20, 20);
            t_arena = createMatrix(12, 20);
            t_player = { pos: {x:0, y:0}, matrix: null, score: 0 };
            t_dropCounter = 0; t_dropInterval = 1000; t_lastTime = 0;
            t_playerReset(); t_updateScore(); t_update();
            createButtons(`<div class="dpad-grid"><div></div><button class="ctrl-btn dpad-btn" id="btn-up">‚ñ≤</button><div></div><button class="ctrl-btn dpad-btn" id="btn-left">‚óÄ</button><button class="ctrl-btn dpad-btn" id="btn-down">‚ñº</button><button class="ctrl-btn dpad-btn" id="btn-right">‚ñ∂</button></div>`);
            document.getElementById('btn-up').onclick = () => t_playerRotate();
            document.getElementById('btn-down').onclick = () => t_playerDrop();
            document.getElementById('btn-left').onclick = () => t_playerMove(-1);
            document.getElementById('btn-right').onclick = () => t_playerMove(1);
        }
        function createMatrix(w, h) { return Array.from({length: h}, () => Array(w).fill(0)); }
        function t_createPiece(type) {
            if (type === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
            if (type === 'L') return [[0,2,0],[0,2,0],[0,2,2]];
            if (type === 'J') return [[0,3,0],[0,3,0],[3,3,0]];
            if (type === 'O') return [[4,4],[4,4]];
            if (type === 'Z') return [[5,5,0],[0,5,5],[0,0,0]];
            if (type === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
            if (type === 'T') return [[0,7,0],[7,7,7],[0,0,0]];
        }
        const t_colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
        function t_draw() { ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height); t_drawMatrix(t_arena, {x:0, y:0}); t_drawMatrix(t_player.matrix, t_player.pos); }
        function t_drawMatrix(matrix, offset) { matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) { ctx.fillStyle = t_colors[value]; ctx.fillRect(x + offset.x, y + offset.y, 1, 1); } }); }); }
        function t_collide(arena, player) { const [m, o] = [player.matrix, player.pos]; for (let y = 0; y < m.length; ++y) { for (let x = 0; x < m[y].length; ++x) { if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true; } } return false; }
        function t_merge(arena, player) { player.matrix.forEach((row, y) => { row.forEach((value, x) => { if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value; }); }); }
        function t_arenaSweep() { let rowCount = 1; outer: for (let y = t_arena.length - 1; y > 0; --y) { for (let x = 0; x < t_arena[y].length; ++x) { if (t_arena[y][x] === 0) continue outer; } const row = t_arena.splice(y, 1)[0].fill(0); t_arena.unshift(row); ++y; t_player.score += rowCount * 10; rowCount *= 2; } t_updateScore(); }
        function t_playerDrop() { t_player.pos.y++; if (t_collide(t_arena, t_player)) { t_player.pos.y--; t_merge(t_arena, t_player); t_playerReset(); t_arenaSweep(); } t_dropCounter = 0; }
        function t_playerMove(dir) { t_player.pos.x += dir; if (t_collide(t_arena, t_player)) t_player.pos.x -= dir; }
        function t_playerRotate() { const matrix = t_player.matrix; for (let y = 0; y < matrix.length; ++y) { for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; } } matrix.forEach(row => row.reverse()); }
        function t_playerReset() { const pieces = 'ILJOTSZ'; t_player.matrix = t_createPiece(pieces[Math.random() * pieces.length | 0]); t_player.pos.y = 0; t_player.pos.x = (t_arena[0].length / 2 | 0) - (t_player.matrix[0].length / 2 | 0); if (t_collide(t_arena, t_player)) { t_arena.forEach(row => row.fill(0)); t_player.score = 0; t_updateScore(); } }
        function t_update(time = 0) { if (currentGame !== 'tetris') return; const deltaTime = time - t_lastTime; t_lastTime = time; t_dropCounter += deltaTime; if (t_dropCounter > t_dropInterval) t_playerDrop(); t_draw(); animationId = requestAnimationFrame(t_update); }
        function t_updateScore() { scoreEl.innerText = "–°—á–µ—Ç: " + t_player.score; }
        function tetrisKeyDown(e) { if (e.keyCode === 37) t_playerMove(-1); else if (e.keyCode === 39) t_playerMove(1); else if (e.keyCode === 40) t_playerDrop(); else if (e.keyCode === 38) t_playerRotate(); }

        /* --- –ó–ú–ï–ô–ö–ê --- */
        let s_score, s_snake, s_food, s_dx, s_dy, s_gridSize, s_tileCount;
        function startSnake() {
            resizeCanvas(400, 400); s_score = 0; s_gridSize = 20; s_tileCount = 20; s_snake = [{x: 10, y: 10}]; s_food = {x: 15, y: 15}; s_dx = 0; s_dy = 0; scoreEl.innerText = 0; clearInterval(gameInterval); gameInterval = setInterval(s_update, 100); s_draw();
            createButtons(`<div class="dpad-grid"><div></div><button class="ctrl-btn dpad-btn" id="btn-up">‚ñ≤</button><div></div><button class="ctrl-btn dpad-btn" id="btn-left">‚óÄ</button><button class="ctrl-btn dpad-btn" id="btn-down">‚ñº</button><button class="ctrl-btn dpad-btn" id="btn-right">‚ñ∂</button></div>`);
            document.getElementById('btn-up').onclick = () => s_setDirection(0, -1); document.getElementById('btn-down').onclick = () => s_setDirection(0, 1); document.getElementById('btn-left').onclick = () => s_setDirection(-1, 0); document.getElementById('btn-right').onclick = () => s_setDirection(1, 0);
        }
        function s_setDirection(x, y) { if (x === -s_dx && s_dx !== 0) return; if (y === -s_dy && s_dy !== 0) return; if (s_dx === 0 && s_dy === 0) { s_dx = x; s_dy = y; } else { s_dx = x; s_dy = y; } }
        function s_update() { if (currentGame !== 'snake') return; if (s_dx === 0 && s_dy === 0) { s_draw(); return; } const head = {x: s_snake[0].x + s_dx, y: s_snake[0].y + s_dy}; if (head.x < 0 || head.x >= s_tileCount || head.y < 0 || head.y >= s_tileCount) { s_gameOver(); return; } for (let part of s_snake) { if (part.x === head.x && part.y === head.y) { s_gameOver(); return; } } s_snake.unshift(head); if (head.x === s_food.x && head.y === s_food.y) { s_score++; scoreEl.innerText = s_score; s_placeFood(); } else { s_snake.pop(); } s_draw(); }
        function s_draw() { ctx.fillStyle = 'black'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#0ff'; for (let part of s_snake) { ctx.fillRect(part.x * s_gridSize, part.y * s_gridSize, s_gridSize - 2, s_gridSize - 2); } ctx.fillStyle = '#e94560'; ctx.fillRect(s_food.x * s_gridSize, s_food.y * s_gridSize, s_gridSize - 2, s_gridSize - 2); if (s_dx === 0 && s_dy === 0) { ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.fillText('–ù–∞–∂–º–∏ —Å—Ç—Ä–µ–ª–∫—É!', canvas.width/2, canvas.height/2); } }
        function s_placeFood() { s_food.x = Math.floor(Math.random() * s_tileCount); s_food.y = Math.floor(Math.random() * s_tileCount); }
        function s_gameOver() { clearInterval(gameInterval); ctx.fillStyle = 'rgba(0,0,0,0.75)'; ctx.fillRect(0,0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = '30px Arial'; ctx.textAlign = 'center'; ctx.fillText('Game Over!', canvas.width/2, canvas.height/2 - 10); ctx.font = '20px Arial'; ctx.fillText('–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É', canvas.width/2, canvas.height/2 + 20); s_dx = 0; s_dy = 0; s_snake = [{x: 10, y: 10}]; s_score = 0; scoreEl.innerText = 0; gameInterval = setInterval(s_update, 100); }
        function snakeKeyDown(e) { switch (e.keyCode) { case 37: s_setDirection(-1, 0); break; case 38: s_setDirection(0, -1); break; case 39: s_setDirection(1, 0); break; case 40: s_setDirection(0, 1); break; } }

        /* --- –ì–û–ù–û–ö --- */
        let r_player, r_enemies, r_score, r_speed, r_roadLine, r_isGameOver;
        function startRacing() {
            resizeCanvas(400, 400); r_player = { x: 175, y: 350, width: 50, height: 80 }; r_enemies = []; r_score = 0; r_speed = 5; r_roadLine = 0; r_isGameOver = false; scoreEl.innerText = 0; r_spawnEnemy();
            createButtons(`<div class="dpad-grid"><div></div><div></div><div></div><button class="ctrl-btn dpad-btn" id="btn-left">‚óÄ</button><div></div><button class="ctrl-btn dpad-btn" id="btn-right">‚ñ∂</button></div>`);
            document.getElementById('btn-left').onclick = () => r_movePlayer(-20); document.getElementById('btn-right').onclick = () => r_movePlayer(20); r_update();
        }
        function r_movePlayer(dir) { r_player.x += dir; if (r_player.x < 50) r_player.x = 50; if (r_player.x + r_player.width > 350) r_player.x = 350 - r_player.width; }
        function r_spawnEnemy() { let x = Math.random() * (300 - 50) + 50; r_enemies.push({ x: x, y: -100, width: 50, height: 80 }); }
        function r_update() { if (currentGame !== 'racing') return; if (r_isGameOver) return; ctx.fillStyle = '#2c3e50'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#7f8c8d'; ctx.fillRect(0, 0, 50, canvas.height); ctx.fillRect(350, 0, 50, canvas.height); r_roadLine += r_speed; if (r_roadLine > 40) r_roadLine = 0; ctx.fillStyle = '#f1c40f'; for (let i = -40; i < canvas.height; i += 40) { ctx.fillRect(195, i + r_roadLine, 10, 20); } if (Math.random() < 0.02) r_spawnEnemy(); r_enemies.forEach((enemy, index) => { enemy.y += r_speed; ctx.fillStyle = '#e74c3c'; ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height); if (r_collision(r_player, enemy)) r_gameOver(); if (enemy.y > canvas.height) { r_enemies.splice(index, 1); r_score++; scoreEl.innerText = r_score; if (r_score % 5 === 0) r_speed += 0.5; } }); ctx.fillStyle = '#3498db'; ctx.fillRect(r_player.x, r_player.y, r_player.width, r_player.height); ctx.fillStyle = '#f1c40f'; ctx.fillRect(r_player.x + 5, r_player.y, 10, 5); ctx.fillRect(r_player.x + 35, r_player.y, 10, 5); animationId = requestAnimationFrame(r_update); }
        function r_collision(rect1, rect2) { return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y; }
        function r_gameOver() { r_isGameOver = true; ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center'; ctx.fillText('–ê–í–ê–†–ò–Ø!', canvas.width/2, canvas.height/2); ctx.font = '20px Arial'; ctx.fillText('–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É', canvas.width/2, canvas.height/2 + 40); }
        function racingKeyDown(e) { if (r_isGameOver) { r_enemies = []; r_score = 0; r_speed = 5; r_isGameOver = false; scoreEl.innerText = 0; r_update(); return; } if (e.keyCode === 37) r_movePlayer(-20); if (e.keyCode === 39) r_movePlayer(20); }

        /* --- –°–ê–ü–Å–† --- */
        let m_grid, m_cols, m_rows, m_cellSize, m_minesCount, m_gameOver, m_flagMode;
        const m_numbers = ['blue', 'green', 'red', 'darkblue', 'brown', 'cyan', 'black', 'grey'];
        function startMinesweeper() {
            m_cols = 10; m_rows = 10; m_cellSize = 30; resizeCanvas(m_cols * m_cellSize, m_rows * m_cellSize); m_minesCount = 15; m_gameOver = false; m_flagMode = false; m_createGrid();
            canvas.onmousedown = (e) => m_handleClick(e); canvas.ontouchstart = (e) => { e.preventDefault(); m_handleClick(e.touches[0]); };
            createButtons(`<div class="ms-controls"><button class="ctrl-btn ms-btn" id="btn-flag">üö© –§–ª–∞–∂–æ–∫</button><button class="ctrl-btn ms-btn" id="btn-restart">üîÑ –ó–∞–Ω–æ–≤–æ</button></div>`);
            document.getElementById('btn-flag').onclick = () => { m_flagMode = !m_flagMode; document.getElementById('btn-flag').style.background = m_flagMode ? '#e94560' : '#0f3460'; document.getElementById('btn-flag').innerText = m_flagMode ? "üö© –†–µ–∂–∏–º: –§–ª–∞–≥" : "üö© –§–ª–∞–∂–æ–∫"; }; document.getElementById('btn-restart').onclick = startMinesweeper;
        }
        function m_createGrid() { m_grid = []; for (let i = 0; i < m_cols; i++) { m_grid[i] = []; for (let j = 0; j < m_rows; j++) { m_grid[i][j] = { mine: false, revealed: false, flagged: false, neighborCount: 0 }; } } let minesPlaced = 0; while (minesPlaced < m_minesCount) { let x = Math.floor(Math.random() * m_cols); let y = Math.floor(Math.random() * m_rows); if (!m_grid[x][y].mine) { m_grid[x][y].mine = true; minesPlaced++; } } for (let i = 0; i < m_cols; i++) { for (let j = 0; j < m_rows; j++) { if (!m_grid[i][j].mine) { m_grid[i][j].neighborCount = m_countMines(i, j); } } } m_draw(); }
        function m_countMines(x, y) { let count = 0; for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { let ni = x + i, nj = y + j; if (ni >= 0 && ni < m_cols && nj >= 0 && nj < m_rows) { if (m_grid[ni][nj].mine) count++; } } } return count; }
        function m_draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); for (let i = 0; i < m_cols; i++) { for (let j = 0; j < m_rows; j++) { let cell = m_grid[i][j]; let x = i * m_cellSize; let y = j * m_cellSize; if (cell.revealed) { ctx.fillStyle = cell.mine ? '#e74c3c' : '#ecf0f1'; } else { ctx.fillStyle = cell.flagged ? '#f1c40f' : '#bdc3c7'; } ctx.fillRect(x + 1, y + 1, m_cellSize - 2, m_cellSize - 2); if (cell.revealed) { if (cell.mine) { ctx.fillStyle = 'black'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText('üí£', x + m_cellSize/2, y + m_cellSize/2 + 5); } else if (cell.neighborCount > 0) { ctx.fillStyle = m_numbers[cell.neighborCount - 1]; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText(cell.neighborCount, x + m_cellSize/2, y + m_cellSize/2 + 5); } } else if (cell.flagged) { ctx.fillStyle = 'red'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText('üö©', x + m_cellSize/2, y + m_cellSize/2 + 5); } } } }
        function m_handleClick(e) { if (m_gameOver) return; let rect = canvas.getBoundingClientRect(); let scaleX = canvas.width / rect.width; let scaleY = canvas.height / rect.height; let x = Math.floor((e.clientX - rect.left) * scaleX / m_cellSize); let y = Math.floor((e.clientY - rect.top) * scaleY / m_cellSize); if (x < 0 || x >= m_cols || y < 0 || y >= m_rows) return; if (m_flagMode) { m_toggleFlag(x, y); } else { m_reveal(x, y); } }
        function m_toggleFlag(x, y) { if (!m_grid[x][y].revealed) { m_grid[x][y].flagged = !m_grid[x][y].flagged; m_draw(); } }
        function m_reveal(x, y) { if (x < 0 || x >= m_cols || y < 0 || y >= m_rows) return; let cell = m_grid[x][y]; if (cell.revealed || cell.flagged) return; cell.revealed = true; if (cell.mine) { m_gameOver = true; scoreEl.innerText = "–ë–ê–ë–ê–•! üí•"; m_revealAll(); m_draw(); return; } if (cell.neighborCount === 0) { for (let i = -1; i <= 1; i++) { for (let j = -1; j <= 1; j++) { m_reveal(x + i, y + j); } } m_draw(); m_checkWin(); } }
        function m_revealAll() { for (let i = 0; i < m_cols; i++) { for (let j = 0; j < m_rows; j++) { m_grid[i][j].revealed = true; } } }
        function m_checkWin() { let unrevealedSafe = 0; for (let i = 0; i < m_cols; i++) { for (let j = 0; j < m_rows; j++) { let c = m_grid[i][j]; if (!c.revealed && !c.mine) unrevealedSafe++; } } if (unrevealedSafe === 0) { scoreEl.innerText = "–ü–û–ë–ï–î–ê! üèÜ"; m_gameOver = true; } }

        /* --- FLAPPY BIRD --- */
        let f_bird, f_pipes, f_score, f_isGameOver, f_velocity;
        const f_gravity = 0.25; const f_jump = -5; const f_pipeSpeed = 2;
        function startFlappy() {
            resizeCanvas(400, 600); f_bird = { x: 80, y: 300, size: 15 }; f_pipes = []; f_score = 0; f_isGameOver = false; f_velocity = 0; scoreEl.innerText = 0;
            createButtons(`<button class="ctrl-btn action-btn" id="btn-flap">–í–ó–õ–ï–¢–ê–¢–¨ üïäÔ∏è</button>`);
            document.getElementById('btn-flap').onclick = () => f_flap(); canvas.onclick = f_flap; f_update();
        }
        function f_flap() { if (f_isGameOver) { cancelAnimationFrame(animationId); startFlappy(); } else { f_velocity = f_jump; } }
        function f_update() {
            if (currentGame !== 'flappy') return; f_velocity += f_gravity; f_bird.y += f_velocity;
            ctx.fillStyle = '#87CEEB'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!f_isGameOver) {
                if (Math.random() < 0.01) { let gap = 150; let h = Math.random() * (canvas.height - gap - 100) + 50; f_pipes.push({ x: canvas.width, h: h, gap: gap, passed: false }); }
                ctx.fillStyle = '#2ecc71';
                for (let i = 0; i < f_pipes.length; i++) {
                    let pipe = f_pipes[i]; pipe.x -= f_pipeSpeed;
                    ctx.fillRect(pipe.x, 0, 50, pipe.h); ctx.fillRect(pipe.x, pipe.h + pipe.gap, 50, canvas.height);
                    if (f_bird.x + f_bird.size > pipe.x && f_bird.x - f_bird.size < pipe.x + 50) { if (f_bird.y - f_bird.size < pipe.h || f_bird.y + f_bird.size > pipe.h + pipe.gap) f_isGameOver = true; }
                    if (pipe.x + 50 < f_bird.x && !pipe.passed) { pipe.passed = true; f_score++; scoreEl.innerText = f_score; }
                }
                if (f_pipes.length && f_pipes[0].x < -50) f_pipes.shift();
                if (f_bird.y + f_bird.size > canvas.height || f_bird.y - f_bird.size < 0) f_isGameOver = true;
            }
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(f_bird.x, f_bird.y, f_bird.size, 0, Math.PI * 2); ctx.fill();
            if (f_isGameOver) { ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2); ctx.font = '20px Arial'; ctx.fillText('–ù–∞–∂–º–∏, —á—Ç–æ–±—ã –ª–µ—Ç–µ—Ç—å', canvas.width/2, canvas.height/2 + 40); return; }
            animationId = requestAnimationFrame(f_update);
        }
        function flappyKeyDown(e) { if (e.keyCode === 32) f_flap(); }

        /* --- ARKANOID --- */
        let a_paddle, a_ball, a_bricks, a_score, a_isGameOver;
        function startArkanoid() {
            resizeCanvas(480, 600); a_paddle = { x: 190, y: 570, w: 100, h: 15 }; a_ball = { x: 240, y: 300, r: 8, dx: 4, dy: -4 }; a_bricks = []; a_score = 0; a_isGameOver = false; scoreEl.innerText = 0;
            for (let i = 0; i < 8; i++) { for (let j = 0; j < 5; j++) { a_bricks.push({ x: 10 + i * 58, y: 50 + j * 25, w: 50, h: 20, alive: true }); } }
            createButtons(`<div class="dpad-grid" style="grid-template-columns: repeat(2, 80px);"><button class="ctrl-btn dpad-btn" style="width:80px; height:60px;" id="btn-a-left">‚óÄ‚óÄ</button><button class="ctrl-btn dpad-btn" style="width:80px; height:60px;" id="btn-a-right">‚ñ∂‚ñ∂</button></div>`);
            document.getElementById('btn-a-left').onclick = () => a_movePaddle(-30); document.getElementById('btn-a-right').onclick = () => a_movePaddle(30); a_update();
        }
        function a_movePaddle(dir) { a_paddle.x += dir; if (a_paddle.x < 0) a_paddle.x = 0; if (a_paddle.x + a_paddle.w > canvas.width) a_paddle.x = canvas.width - a_paddle.w; }
        function a_update() {
            if (currentGame !== 'arkanoid') return; if (a_isGameOver) return;
            a_ball.x += a_ball.dx; a_ball.y += a_ball.dy;
            if (a_ball.x > canvas.width - a_ball.r || a_ball.x < a_ball.r) a_ball.dx *= -1; if (a_ball.y < a_ball.r) a_ball.dy *= -1;
            if (a_ball.y + a_ball.r > a_paddle.y && a_ball.x > a_paddle.x && a_ball.x < a_paddle.x + a_paddle.w) { a_ball.dy = -Math.abs(a_ball.dy); let hitPos = (a_ball.x - a_paddle.x) / a_paddle.w; a_ball.dx = 8 * (hitPos - 0.5); }
            if (a_ball.y > canvas.height) a_isGameOver = true;
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            let allBroken = true;
            a_bricks.forEach(brick => { if (!brick.alive) return; allBroken = false; ctx.fillStyle = '#e74c3c'; ctx.fillRect(brick.x, brick.y, brick.w, brick.h); if (a_ball.x + a_ball.r > brick.x && a_ball.x - a_ball.r < brick.x + brick.w && a_ball.y + a_ball.r > brick.y && a_ball.y - a_ball.r < brick.y + brick.h) { brick.alive = false; a_ball.dy *= -1; a_score++; scoreEl.innerText = a_score; } });
            ctx.fillStyle = '#3498db'; ctx.fillRect(a_paddle.x, a_paddle.y, a_paddle.w, a_paddle.h);
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(a_ball.x, a_ball.y, a_ball.r, 0, Math.PI * 2); ctx.fill();
            if (allBroken) { a_isGameOver = true; ctx.fillStyle = 'rgba(0,255,0,0.5)'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center'; ctx.fillText('–ü–û–ë–ï–î–ê!', canvas.width/2, canvas.height/2); return; }
            if (a_isGameOver) { ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center'; ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2); return; }
            animationId = requestAnimationFrame(a_update);
        }
        function arkanoidKeyDown(e) { if (e.keyCode === 37) a_movePaddle(-30); if (e.keyCode === 39) a_movePaddle(30); }

        /* --- BLOCK BLAST (–ò–°–ü–†–ê–í–õ–ï–ù–û: –õ–ï–ì–ö–û –£–ü–†–ê–í–õ–Ø–¢–¨) --- */
        let bb_grid, bb_score, bb_highScore, bb_cellSize, bb_cols, bb_rows, bb_pieces, bb_dragPiece, bb_dragPos, bb_gameOver, bb_trayY, bb_validPos, bb_flash;
        const bb_colors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c'];

        function startBlockBlast() {
            bb_cols = 8; bb_rows = 8; bb_cellSize = 36;
            let gridH = bb_cols * bb_cellSize;
            bb_trayY = gridH + 15;
            resizeCanvas(gridH, gridH + 130);

            bb_highScore = localStorage.getItem('bb_highscore') || 0;
            bb_grid = [];
            for(let i=0; i<bb_cols; i++) {
                bb_grid[i] = [];
                for(let j=0; j<bb_rows; j++) bb_grid[i][j] = 0;
            }
            
            bb_score = 0;
            bb_gameOver = false;
            bb_flash = 0;
            bb_pieces = [];
            bb_dragPiece = null;
            bb_validPos = null;
            
            bb_generatePieces();
            bb_updateScore();
            
            const getPos = (e) => {
                let rect = canvas.getBoundingClientRect();
                let scaleX = canvas.width / rect.width;
                let scaleY = canvas.height / rect.height;
                let clientX = e.clientX || (e.touches && e.touches[0].clientX);
                let clientY = e.clientY || (e.touches && e.touches[0].clientY);
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            };

            canvas.onmousedown = (e) => { e.preventDefault(); bb_onDown(getPos(e)); };
            canvas.ontouchstart = (e) => { e.preventDefault(); bb_onDown(getPos(e)); };

            canvas.onmousemove = (e) => { bb_onMove(getPos(e)); };
            canvas.ontouchmove = (e) => { e.preventDefault(); bb_onMove(getPos(e)); };

            window.onmouseup = (e) => { bb_onUp(getPos(e)); };
            window.ontouchend = (e) => { bb_onUp(getPos(e)); };

            createButtons(`<button class="ctrl-btn action-btn" onclick="startBlockBlast()">üîÑ –ó–∞–Ω–æ–≤–æ</button>`);
            bb_draw();
        }

        function bb_generatePieces() {
            bb_pieces = [];
            let space = canvas.width / 3;
            let shapes = [
                [[1,1,1]], [[1,1],[1,1]], [[1,0],[1,1]], [[0,1],[1,1]], 
                [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[0,1,0],[1,1,1]], [[1]], [[1,1]], [[1],[1]]
            ];
            for(let i=0; i<3; i++) {
                let shape = shapes[Math.floor(Math.random() * shapes.length)];
                let color = bb_colors[Math.floor(Math.random() * bb_colors.length)];
                // –†–∞–∑–º–µ—Ä —Ñ–∏–≥—É—Ä—ã –≤ –ø–∏–∫—Å–µ–ª—è—Ö –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è
                let pieceDrawSize = 30; 
                let w = shape[0].length * pieceDrawSize;
                let h = shape.length * pieceDrawSize;
                let x = i * space + (space/2) - w/2;
                let y = bb_trayY + 20;
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏ —Ä–∞–∑–º–µ—Ä –∫–ª–µ—Ç–∫–∏ –ø–æ–ª—è (cellSize) –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
                bb_pieces.push({ shape, color, x, y, w, h, pieceDrawSize, used: false });
            }
            if (!bb_canPlaceAny()) bb_gameOver = true;
        }

        function bb_draw() {
            if (currentGame !== 'blockblast') return;
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (bb_flash > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${bb_flash})`;
                ctx.fillRect(0, 0, canvas.width, bb_trayY);
                bb_flash -= 0.1;
            }

            // –°–µ—Ç–∫–∞
            for(let i=0; i<bb_cols; i++) {
                for(let j=0; j<bb_rows; j++) {
                    let val = bb_grid[i][j];
                    ctx.fillStyle = val ? val : '#222';
                    roundRect(ctx, i * bb_cellSize + 1, j * bb_cellSize + 1, bb_cellSize - 2, bb_cellSize - 2, 3, val ? val : '#222', val ? 0 : 1);
                }
            }
            
            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(0, bb_trayY - 5);
            ctx.lineTo(canvas.width, bb_trayY - 5);
            ctx.stroke();

            // –§–∏–≥—É—Ä—ã –≤ —Ç—Ä–µ–∏ (—Ä–∏—Å—É–µ–º —Å –∏—Ö –ª–∏—á–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º pieceDrawSize)
            bb_pieces.forEach(p => { if(!p.used) bb_drawShape(p.shape, p.x, p.y, p.color, p.pieceDrawSize); });

            // –¢–µ–Ω—å
            if (bb_dragPiece && bb_validPos) {
                let color = bb_validPos.valid ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.2)';
                if (bb_validPos.valid) {
                     bb_drawShapeOnGrid(bb_dragPiece.shape, bb_validPos.x, bb_validPos.y, color);
                }
            }

            // –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–∞—è —Ñ–∏–≥—É—Ä–∞
            if (bb_dragPiece) {
                // –†–∏—Å—É–µ–º –µ—ë —Ç–∞–º, –≥–¥–µ –∫—É—Ä—Å–æ—Ä, –Ω–æ —Ä–∞–∑–º–µ—Ä –±–µ—Ä–µ–º –∏–∑ –µ—ë —Å–≤–æ–π—Å—Ç–≤
                let offsetX = bb_dragPiece.w / 2;
                let offsetY = bb_dragPiece.h / 2;
                bb_drawShape(bb_dragPiece.shape, bb_dragPos.x - offsetX, bb_dragPos.y - offsetY, bb_dragPiece.color, bb_dragPiece.pieceDrawSize);
            }
            
            ctx.fillStyle = '#888';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('–†–µ–∫–æ—Ä–¥: ' + bb_highScore, 5, 15);

            if (bb_gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('–ò–ì–†–ê', canvas.width/2, canvas.height/2 - 30);
                ctx.fillText('–û–ö–û–ù–ß–ï–ù–ê', canvas.width/2, canvas.height/2 + 20);
                ctx.font = '16px Arial';
                ctx.fillText('–ù–∞–∂–º–∏ "–ó–∞–Ω–æ–≤–æ"', canvas.width/2, canvas.height/2 + 60);
            }
            
            if (bb_flash > 0) requestAnimationFrame(bb_draw);
        }

        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) { ctx.fillStyle = fill; ctx.fill(); }
            if (stroke) { ctx.strokeStyle = '#333'; ctx.stroke(); }
        }

        function bb_drawShape(shape, x, y, color, size) {
            shape.forEach((row, rj) => {
                row.forEach((val, ri) => {
                    if(val) {
                        roundRect(ctx, x + ri * size + 1, y + rj * size + 1, size - 2, size - 2, 3, color, 0);
                    }
                });
            });
        }

        function bb_drawShapeOnGrid(shape, gx, gy, color) {
            shape.forEach((row, rj) => {
                row.forEach((val, ri) => {
                    if(val && gx + ri >= 0 && gy + rj >= 0) {
                         roundRect(ctx, (gx + ri) * bb_cellSize, (gy + rj) * bb_cellSize, bb_cellSize - 2, bb_cellSize - 2, 3, color, 0);
                    }
                });
            });
        }

        function bb_onDown(pos) {
            if (bb_gameOver) return;
            for (let i = bb_pieces.length - 1; i >= 0; i--) {
                let p = bb_pieces[i];
                if (!p.used && pos.x > p.x && pos.x < p.x + p.w && pos.y > p.y && pos.y < p.y + p.h) {
                    bb_dragPiece = p;
                    bb_dragPos = pos;
                    bb_draw();
                    return;
                }
            }
        }

        function bb_onMove(pos) {
            if (bb_dragPiece) {
                bb_dragPos = pos;
                
                // –ì–õ–ê–í–ù–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Ñ–∏–≥—É—Ä—É –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫—É—Ä—Å–æ—Ä–∞
                // –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ –±–ª–∏–∂–∞–π—à–µ–π –∫–ª–µ—Ç–∫–∏ (round), —á—Ç–æ–±—ã —Ñ–∏–≥—É—Ä–∞ "–ø—Ä–∏–ª–∏–ø–∞–ª–∞" –∫ —Å–µ—Ç–∫–µ
                let shapeW = bb_dragPiece.shape[0].length;
                let shapeH = bb_dragPiece.shape.length;
                
                let tx = Math.round((pos.x / bb_cellSize) - (shapeW / 2));
                let ty = Math.round((pos.y / bb_cellSize) - (shapeH / 2));

                let canPlace = bb_canPlace(bb_dragPiece.shape, tx, ty);
                bb_validPos = {x: tx, y: ty, valid: canPlace};
                
                bb_draw();
            }
        }

        function bb_onUp(pos) {
            if (!bb_dragPiece) return;
            
            if (bb_validPos && bb_validPos.valid) {
                bb_placeShape(bb_dragPiece.shape, bb_validPos.x, bb_validPos.y, bb_dragPiece.color);
                bb_dragPiece.used = true;
                
                let cleared = bb_checkLines();
                if (cleared > 0) bb_flash = 0.5;
                
                bb_updateScore();
                
                if(bb_pieces.every(p => p.used)) bb_generatePieces();
                else if (!bb_canPlaceAny()) bb_gameOver = true;
            }
            
            bb_dragPiece = null;
            bb_validPos = null;
            bb_draw();
        }

        function bb_canPlace(shape, gx, gy) {
            for(let rj=0; rj<shape.length; rj++) {
                for(let ri=0; ri<shape[rj].length; ri++) {
                    if(shape[rj][ri]) {
                        let x = gx + ri; let y = gy + rj;
                        if (x < 0 || x >= bb_cols || y < 0 || y >= bb_rows || bb_grid[x][y]) return false;
                    }
                }
            }
            return true;
        }

        function bb_placeShape(shape, gx, gy, color) {
            shape.forEach((row, rj) => {
                row.forEach((val, ri) => {
                    if(val) { bb_grid[gx + ri][gy + rj] = color; bb_score += 10; }
                });
            });
        }

        function bb_checkLines() {
            let linesCleared = 0;
            for(let j=bb_rows-1; j>=0; j--) {
                if(bb_grid.every(col => col[j])) {
                    for(let i=0; i<bb_cols; i++) bb_grid[i][j] = 0;
                    linesCleared++;
                }
            }
            for(let i=0; i<bb_cols; i++) {
                if(bb_grid[i].every(cell => cell)) {
                    for(let j=0; j<bb_rows; j++) bb_grid[i][j] = 0;
                    linesCleared++;
                }
            }
            
            if (linesCleared > 0) {
                let bonus = [0, 100, 300, 500, 800];
                bb_score += bonus[Math.min(linesCleared, 4)];
                
                if (bb_score > bb_highScore) {
                    bb_highScore = bb_score;
                    localStorage.setItem('bb_highscore', bb_highScore);
                }
            }
            
            return linesCleared;
        }

        function bb_canPlaceAny() {
            for(let p of bb_pieces) {
                if(p.used) continue;
                for(let i=0; i<bb_cols; i++) for(let j=0; j<bb_rows; j++) if(bb_canPlace(p.shape, i, j)) return true;
            }
            return false;
        }

        function bb_updateScore() { scoreEl.innerText = "–°—á–µ—Ç: " + bb_score; }

    </script>
</body>
</html>
